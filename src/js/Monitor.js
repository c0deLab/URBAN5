import ID from './ID';
import ActionsEnum from './enums/ActionsEnum';
import { getCellContext3D } from './ArrayHelpers';

/* global SETTINGS */

const LABEL = {
  NOT_POSSIBLE: 'Not structurally possible at this time.',
  SOME_INCOMPATIBILITIES: 'Ted, there are some incompatibilities occurring.',
  MANY_INCOMPATIBILITIES: 'Ted, many incompatibilities are occurring.',
  WELCOME: 'Welcome, this is URBAN5.'
};

const MESSAGE = {
  WELCOME: { name: 'WELCOME', type: 'message', text: LABEL.WELCOME },
};

const INCOMPATIBILITY = {
  IS_COLLISION: { text: 'There is something there already.' },
  IS_BELOW_GROUND: { text: `${LABEL.NOT_POSSIBLE} The object is below ground.` },
  IS_FLOATING: { text: `${LABEL.NOT_POSSIBLE} The object is floating.` },
  NO_GROUND_BELOW: { text: `${LABEL.NOT_POSSIBLE} There is no ground below.` },
  NO_BUILDING_BELOW: { text: `${LABEL.NOT_POSSIBLE} There is no building below.` },
  MULTIPLE: { text: LABEL.MANY_INCOMPATIBILITIES },
  SOME: { text: LABEL.SOME_INCOMPATIBILITIES },
};

/** Class to monitor the actions of the user */
export default class Monitor {
  constructor(actionsAPI, model) {
    this.listeners = [];
    this.messagesID = new ID();
    this.messages = [this.createMessage(MESSAGE.WELCOME)];

    // listen and respond to events with messages
    actionsAPI.addListener(this);

    this.model = model;
  }

  addListener = listener => this.listeners.push(listener);

  removeListener = toRemove => this.listeners.filter(listener => listener !== toRemove);

  getMessages = () => this.messages;

  onAction = actionEvent => {
    const { action, metadata } = actionEvent;

    if (action === ActionsEnum.SPEAK_CONSTRAINT) {
      // add constraint
      console.log(`Add Constraint: ${metadata.text}`);
      this.sendMessage({ text: metadata.text });
    }

    // console.log(JSON.stringify(actionEvent));
    this.checkIncompatibilities(actionEvent);
    this.checkConflicts(actionEvent);
  };

  /**
    * Conflict “An inconsistency discerned by the machine relating criteria specified by the designer
    * to forms generated by the designer.”
    * Examples: max height, number of objects, light, blocking entrances, check access
    */
  checkConflicts = actionEvent => {
    // TODO
  };

  /**
    * Incompatibility: “incongruity between a designer’s action and a predefined requisite embedded in the machine.”
    * Leads to a bell ringing and displaying the message on the top of the screen
    * Examples: underground, floating, clash
    */
  checkIncompatibilities = actionEvent => {
    if (ActionsEnum.isAdd(actionEvent.action)) {
      // If the user added an object, check that position
      const { metadata } = actionEvent;
      const { modelPosition } = metadata;
      const incompatibilities = this.getIncompatibilitiesAtPosition(modelPosition);
      incompatibilities.forEach(i => this.sendMessage(i));
    } else if (ActionsEnum.EDITTOPO === actionEvent.action || ActionsEnum.REMOVE === actionEvent.action) {
      // If the user set the topo height or remove something, check all incompatibilities
      const incompatibilities = this.getAllIncompatibilities();
      if (incompatibilities.length > 5) {
        this.sendMessage(INCOMPATIBILITY.MULTIPLE);
      } else if (incompatibilities.length > 0) {
        this.sendMessage(INCOMPATIBILITY.SOME);
      }
    }
  };

  getAllIncompatibilities = () => {
    const incompatibilities = [];

    // check default constraints
    const { objects } = this.model;
    for (let z = 0; z < SETTINGS.zMax; z += 1) {
      for (let y = 0; y < SETTINGS.yMax; y += 1) {
        for (let x = 0; x < SETTINGS.xMax; x += 1) {
          if (objects[z][y][x] !== null) {
            const modelPosition = { x, y, z };
            incompatibilities.push(...this.getIncompatibilitiesAtPosition(modelPosition));
          }
        }
      }
    }

    return incompatibilities;
  };

  getIncompatibilitiesAtPosition = modelPosition => {
    const incompatibilities = [];
    if (this.isBelowGround(modelPosition)) {
      incompatibilities.push(INCOMPATIBILITY.IS_BELOW_GROUND);
    }
    // else if (this.isCollision(modelPosition)) {
    //   incompatibilities.push(INCOMPATIBILITY.IS_COLLISION);
    // }

    const { x, y, z } = modelPosition;
    const obj = this.model.objects[z][y][x];

    if (obj) {
      if (obj.constructor.name === 'Cube') {
        // If it is a cube, it needs another cube touching it or ground underneath
        if (!(this.isCubeConnected(modelPosition) || this.isOnGround(modelPosition))) {
          incompatibilities.push(INCOMPATIBILITY.IS_FLOATING);
        }
      } else if (obj.constructor.name === 'Trunk') {
        // If its a tree, it needs ground underneath
        if (!this.isOnGround(modelPosition)) {
          incompatibilities.push(INCOMPATIBILITY.NO_GROUND_BELOW);
        }
      } else if (obj.constructor.name === 'Roof') {
        // If it is a roof, it needs a cube underneath
        if (!this.isCubeBelow(modelPosition)) {
          incompatibilities.push(INCOMPATIBILITY.NO_BUILDING_BELOW);
        }
      }
    }

    return incompatibilities;
  };

  createMessage = data => {
    const message = { id: this.messagesID.getNextID(), data };
    return message;
  };

  sendMessage = data => {
    const newMessage = this.createMessage(data);
    this.listeners.forEach(listener => listener.onMessage(newMessage));
  };

  isCollision = modelPosition => {
    const { x, y, z } = modelPosition;

    const isCollision = this.model.objects[z][y][x] !== null;
    // console.log('isCollision', isCollision);
    return isCollision;
  };

  isBelowGround = modelPosition => {
    const { heights } = this.model.topo;
    const { x, y, z } = modelPosition;
    const groundHeight = heights[y][x];
    const belowGroud = z < groundHeight;
    // console.log('belowGroud', belowGroud);
    return belowGroud;
  };

  isOnGround = modelPosition => {
    const { x, y, z } = modelPosition;
    const { heights } = this.model.topo;
    const groundHeight = heights[y][x];
    const onGround = z === groundHeight;
    // console.log('onGround', onGround);
    return onGround;
  };

  isCubeConnected = modelPosition => {
    const {
      n, e, s, w, t, b
    } = getCellContext3D(this.model.objects, modelPosition);

    // Check the context around it to see if any are cubes
    const cubeConnected = (n && n.constructor.name === 'Cube')
      || (e && e.constructor.name === 'Cube')
      || (s && s.constructor.name === 'Cube')
      || (w && w.constructor.name === 'Cube')
      || (t && t.constructor.name === 'Cube')
      || (b && b.constructor.name === 'Cube');
    return cubeConnected;
  };

  isCubeBelow = modelPosition => {
    const { x, y, z } = modelPosition;
    if (z < 1) {
      return false;
    }

    const b = this.model.objects[z - 1][y][x];
    return b && b.constructor.name === 'Cube';
  };
}
