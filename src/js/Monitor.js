import ID from './ID';
import ActionsEnum from './enums/ActionsEnum';
import ObjectsEnum from './enums/ObjectsEnum';
import { getCellContext3D } from './ArrayHelpers';

const LABEL = {
  NOT_POSSIBLE: 'Not structurally possible at this time.',
  SOME_INCOMPATIBILITIES: 'Ted, there are some incompatibilities occurring.',
  MANY_INCOMPATIBILITIES: 'Ted, many incompatibilities are occurring.',
  WELCOME: 'Welcome, this is URBAN5.'
};

const MESSAGE = {
  WELCOME: { name: 'WELCOME', type: 'message', text: LABEL.WELCOME },
};

const INCOMPATIBILITY = {
  IS_COLLISION: { text: `${LABEL.NOT_POSSIBLE} There is something there already.` },
  IS_BELOW_GROUND: { text: `${LABEL.NOT_POSSIBLE} The object is below ground.` },
  IS_FLOATING: { text: `${LABEL.NOT_POSSIBLE} The object is floating.` },
  NO_GROUND_BELOW: { text: `${LABEL.NOT_POSSIBLE} There is no ground below.` },
  NO_BUILDING_BELOW: { text: `${LABEL.NOT_POSSIBLE} There is no building below.` },
  MULTIPLE: { text: LABEL.MANY_INCOMPATIBILITIES },
  SOME: { text: LABEL.SOME_INCOMPATIBILITIES },
};

/** Class to monitor the actions of the user */
export default class Monitor {
  constructor(actionsAPI, model) {
    this.listeners = [];
    this.messagesID = new ID();
    this.messages = [this.createMessage(MESSAGE.WELCOME)];

    // listen and respond to events with messages
    actionsAPI.addListener(this);

    this.model = model;
  }

  addListener = listener => this.listeners.push(listener);

  removeListener = toRemove => this.listeners.filter(listener => listener !== toRemove);

  getMessages = () => this.messages;

  onAction = actionEvent => {
    const { action, metadata } = actionEvent;

    if (action === ActionsEnum.SPEAK_CONSTRAINT) {
      // add constraint
      console.log(`Add Constraint: ${metadata.text}`);
      this.sendMessage({ text: metadata.text });
    }

    // console.log(JSON.stringify(actionEvent));
    this.checkIncompatibilities(actionEvent);
    this.checkConflicts(actionEvent);
  };

  /**
    * Conflict “An inconsistency discerned by the machine relating criteria specified by the designer
    * to forms generated by the designer.”
    * Examples: max height, number of objects, light, blocking entrances, check access
    */
  checkConflicts = actionEvent => {
    // TODO
  };

  /**
    * Incompatibility: “incongruity between a designer’s action and a predefined requisite embedded in the machine.”
    * Leads to a bell ringing and displaying the message on the top of the screen
    * Examples: underground, floating, clash
    */
  checkIncompatibilities = actionEvent => {
    if (ActionsEnum.isAdd(actionEvent.action)) {
      // If the user added an object, check that if it encounters another object
      const { action, metadata } = actionEvent;
      const { modelPosition } = metadata;

      if (this.isBelowGround(modelPosition)) {
        this.sendMessage(INCOMPATIBILITY.IS_BELOW_GROUND);
      } else if (this.isCollision(modelPosition)) {
        this.sendMessage(INCOMPATIBILITY.IS_COLLISION);
      }

      switch (action) {
        case ActionsEnum.ADDTREE:
          // If its a tree, it needs ground underneath
          if (!this.isOnGround(modelPosition)) {
            this.sendMessage(INCOMPATIBILITY.NO_GROUND_BELOW);
          }
          break;
        case ActionsEnum.ADDCUBE:
          // If it is a cube, it needs another cube touching it or ground underneath
          if (!(this.isCubeConnected(modelPosition) || this.isOnGround(modelPosition))) {
            this.sendMessage(INCOMPATIBILITY.IS_FLOATING);
          }
          break;
        case ActionsEnum.ADDRFLFT:
        case ActionsEnum.ADDRFRGT:
          // If it is a roof, it needs a cube underneath
          if (!this.isCubeBelow(modelPosition)) {
            this.sendMessage(INCOMPATIBILITY.NO_BUILDING_BELOW);
          }
          break;
        default:
          // nothing
          break;
      }
    } else if (ActionsEnum.EDITTOPO === actionEvent.action) {
      // If the user set the topo height, check all incompatibilities
      const numIncompatibilities = this.getAllIncompatibilities();
      // console.log('numIncompatibilities', numIncompatibilities);
      if (numIncompatibilities > 5) {
        this.sendMessage(INCOMPATIBILITY.MULTIPLE);
      } else if (numIncompatibilities > 0) {
        this.sendMessage(INCOMPATIBILITY.SOME);
      }
    }
  };

  getAllIncompatibilities = () => {
    const xMax = 17;
    const yMax = 17;
    const zMax = 7;

    let incompatibilities = 0;

    // check default constraints
    const { objects } = this.model;
    for (let z = 0; z < zMax; z += 1) {
      for (let y = 0; y < xMax; y += 1) {
        for (let x = 0; x < yMax; x += 1) {
          if (objects[z][y][x] !== null) {
            const modelPosition = { x, y, z };
            const isStructurallyPossible = this.isStructurallyPossible(modelPosition);
            if (!isStructurallyPossible) {
              console.log(`incompatibility at: ${JSON.stringify({ x, y, z })}`);
              incompatibilities += 1;
            }
          }
        }
      }
    }

    return incompatibilities;
  };

  createMessage = data => {
    const message = { id: this.messagesID.getNextID(), data };
    return message;
  };

  sendMessage = data => {
    const newMessage = this.createMessage(data);
    this.listeners.forEach(listener => listener.onMessage(newMessage));
  };

  isStructurallyPossible = modelPosition => {
    const isBelowGround = this.isBelowGround(modelPosition);
    const isFloating = this.isFloating(modelPosition);
    return !isBelowGround && !isFloating;
  };

  isCollision = modelPosition => {
    const { x, y, z } = modelPosition;

    const isCollision = this.model.objects[z][y][x] !== null;
    // console.log('isCollision', isCollision);
    return isCollision;
  };

  isBelowGround = modelPosition => {
    const { heights } = this.model.topo;
    const { x, y, z } = modelPosition;
    const groundHeight = heights[y][x];
    const belowGroud = z < groundHeight;
    // console.log('belowGroud', belowGroud);
    return belowGroud;
  };

  isFloating = (action, modelPosition) => {
    switch (action) {
      case ActionsEnum.ADDTREE:
        // If its a tree, it needs ground underneath
        return !this.isOnGround(modelPosition);
      case ActionsEnum.ADDCUBE:
        // If it is a cube, it needs another cube touching it or ground underneath
        return !(this.isCubeConnected(modelPosition) || this.isOnGround(modelPosition));
      case ActionsEnum.ADDRFLFT:
      case ActionsEnum.ADDRFRGT:
        // If it is a roof, it needs a cube underneath
        return !this.isCubeBelow(modelPosition);
      default:
        // nothing
        break;
    }
    return null;
  };

  isOnGround = modelPosition => {
    const { x, y, z } = modelPosition;
    const { heights } = this.model.topo;
    const groundHeight = heights[y][x];
    const onGround = z === groundHeight;
    // console.log('onGround', onGround);
    return onGround;
  };

  isCubeConnected = modelPosition => {
    const { x, y, z } = modelPosition;
    const {
      left, front, right, back, top, bottom
    } = getCellContext3D(this.model.objects, x, y, z);

    // Check the context around it to see if any are cubes
    const cubeConnected = left === ObjectsEnum.CUBE || front === ObjectsEnum.CUBE || right === ObjectsEnum.CUBE
      || back === ObjectsEnum.CUBE || top === ObjectsEnum.CUBE || bottom === ObjectsEnum.CUBE;
    // console.log('cubeConnected', cubeConnected);
    return cubeConnected;
  };

  isCubeBelow = modelPosition => {
    const { x, y, z } = modelPosition;
    if (z < 1) {
      return false;
    }

    return this.model.objects[z - 1][y][x] === ObjectsEnum.CUBE;
  };
}
